{
  "author": {
    "name": "Powerhouse",
    "website": "https://www.powerhouse.inc/"
  },
  "description": "Defines a service offering with tiered pricing, service groups, option groups, and facet-based targeting.",
  "extension": "phso",
  "id": "powerhouse/service-offering",
  "name": "ServiceOffering",
  "specifications": [
    {
      "changeLog": [],
      "modules": [
        {
          "description": "Offering-level metadata, status, target audiences, facet targets, and resource templates",
          "id": "mod-offering",
          "name": "offering",
          "operations": [
            {
              "description": "Update offering title, summary, description, URLs",
              "errors": [],
              "examples": [],
              "id": "op-update-offering-info",
              "name": "UPDATE_OFFERING_INFO",
              "reducer": "if (action.input.title) state.title = action.input.title;\nif (action.input.summary) state.summary = action.input.summary;\nif (action.input.description !== undefined) state.description = action.input.description || null;\nif (action.input.thumbnailUrl !== undefined) state.thumbnailUrl = action.input.thumbnailUrl || null;\nif (action.input.infoLink !== undefined) state.infoLink = action.input.infoLink || null;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateOfferingInfoInput {\n    title: String\n    summary: String\n    description: String\n    thumbnailUrl: URL\n    infoLink: URL\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update offering title, summary, description, URLs"
            },
            {
              "description": "Change offering status",
              "errors": [],
              "examples": [],
              "id": "op-update-offering-status",
              "name": "UPDATE_OFFERING_STATUS",
              "reducer": "state.status = action.input.status;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateOfferingStatusInput {\n    status: ServiceStatus!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Change offering status"
            },
            {
              "description": "Set operator ID",
              "errors": [],
              "examples": [],
              "id": "op-set-operator",
              "name": "SET_OPERATOR",
              "reducer": "state.operatorId = action.input.operatorId;\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetOperatorInput {\n    operatorId: PHID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set operator ID"
            },
            {
              "description": "Set offering ID",
              "errors": [],
              "examples": [],
              "id": "op-set-offering-id",
              "name": "SET_OFFERING_ID",
              "reducer": "state.id = action.input.id;\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetOfferingIdInput {\n    id: PHID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set offering ID"
            },
            {
              "description": "Add a target audience",
              "errors": [],
              "examples": [],
              "id": "op-add-target-audience",
              "name": "ADD_TARGET_AUDIENCE",
              "reducer": "state.targetAudiences.push({\n    id: action.input.id,\n    label: action.input.label,\n    color: action.input.color || null,\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddTargetAudienceInput {\n    id: OID!\n    label: String!\n    color: String\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a target audience"
            },
            {
              "description": "Remove a target audience by ID",
              "errors": [
                {
                  "code": "TARGET_AUDIENCE_NOT_FOUND",
                  "description": "Target audience with given ID not found",
                  "id": "err-remove-ta-not-found",
                  "name": "RemoveTargetAudienceNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-target-audience",
              "name": "REMOVE_TARGET_AUDIENCE",
              "reducer": "const index = state.targetAudiences.findIndex(ta => ta.id === action.input.id);\nif (index === -1) {\n    throw new RemoveTargetAudienceNotFoundError(`Target audience with ID ${action.input.id} not found`);\n}\nstate.targetAudiences.splice(index, 1);\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveTargetAudienceInput {\n    id: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove a target audience by ID"
            },
            {
              "description": "Set or upsert a facet target category",
              "errors": [],
              "examples": [],
              "id": "op-set-facet-target",
              "name": "SET_FACET_TARGET",
              "reducer": "const existingIndex = state.facetTargets.findIndex(ft => ft.categoryKey === action.input.categoryKey);\nconst facetTarget = {\n    id: action.input.id,\n    categoryKey: action.input.categoryKey,\n    categoryLabel: action.input.categoryLabel,\n    selectedOptions: action.input.selectedOptions,\n};\nif (existingIndex !== -1) {\n    state.facetTargets[existingIndex] = facetTarget;\n} else {\n    state.facetTargets.push(facetTarget);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetFacetTargetInput {\n    id: OID!\n    categoryKey: String!\n    categoryLabel: String!\n    selectedOptions: [String!]!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set or upsert a facet target category"
            },
            {
              "description": "Remove a facet target by category key",
              "errors": [
                {
                  "code": "FACET_TARGET_NOT_FOUND",
                  "description": "Facet target with given category key not found",
                  "id": "err-remove-ft-not-found",
                  "name": "RemoveFacetTargetNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-facet-target",
              "name": "REMOVE_FACET_TARGET",
              "reducer": "const index = state.facetTargets.findIndex(ft => ft.categoryKey === action.input.categoryKey);\nif (index === -1) {\n    throw new RemoveFacetTargetNotFoundError(`Facet target with category key ${action.input.categoryKey} not found`);\n}\nstate.facetTargets.splice(index, 1);\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveFacetTargetInput {\n    categoryKey: String!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove a facet target by category key"
            },
            {
              "description": "Add an option to an existing facet target",
              "errors": [
                {
                  "code": "FACET_TARGET_NOT_FOUND",
                  "description": "Facet target with given category key not found",
                  "id": "err-add-fo-target-not-found",
                  "name": "AddFacetOptionTargetNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-facet-option",
              "name": "ADD_FACET_OPTION",
              "reducer": "const facetTarget = state.facetTargets.find(ft => ft.categoryKey === action.input.categoryKey);\nif (!facetTarget) {\n    throw new AddFacetOptionTargetNotFoundError(`Facet target with category key ${action.input.categoryKey} not found`);\n}\nfacetTarget.selectedOptions.push(action.input.optionId);\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddFacetOptionInput {\n    categoryKey: String!\n    optionId: String!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add an option to an existing facet target"
            },
            {
              "description": "Remove an option from a facet target",
              "errors": [
                {
                  "code": "FACET_TARGET_NOT_FOUND",
                  "description": "Facet target with given category key not found",
                  "id": "err-remove-fo-target-not-found",
                  "name": "RemoveFacetOptionTargetNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-facet-option",
              "name": "REMOVE_FACET_OPTION",
              "reducer": "const facetTarget = state.facetTargets.find(ft => ft.categoryKey === action.input.categoryKey);\nif (!facetTarget) {\n    throw new RemoveFacetOptionTargetNotFoundError(`Facet target with category key ${action.input.categoryKey} not found`);\n}\nconst optIndex = facetTarget.selectedOptions.indexOf(action.input.optionId);\nif (optIndex !== -1) {\n    facetTarget.selectedOptions.splice(optIndex, 1);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveFacetOptionInput {\n    categoryKey: String!\n    optionId: String!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove an option from a facet target"
            },
            {
              "description": "Select a resource template",
              "errors": [],
              "examples": [],
              "id": "op-select-resource-template",
              "name": "SELECT_RESOURCE_TEMPLATE",
              "reducer": "state.resourceTemplateId = action.input.resourceTemplateId;\nstate.lastModified = action.input.lastModified;",
              "schema": "input SelectResourceTemplateInput {\n    resourceTemplateId: PHID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Select a resource template"
            },
            {
              "description": "Change the resource template",
              "errors": [
                {
                  "code": "TEMPLATE_MISMATCH",
                  "description": "The previous template ID does not match the current resource template",
                  "id": "err-change-rt-mismatch",
                  "name": "ChangeResourceTemplateMismatchError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-change-resource-template",
              "name": "CHANGE_RESOURCE_TEMPLATE",
              "reducer": "if (state.resourceTemplateId !== action.input.previousTemplateId) {\n    throw new ChangeResourceTemplateMismatchError(`Current template ${state.resourceTemplateId} does not match previous template ${action.input.previousTemplateId}`);\n}\nstate.resourceTemplateId = action.input.newTemplateId;\nstate.lastModified = action.input.lastModified;",
              "schema": "input ChangeResourceTemplateInput {\n    previousTemplateId: PHID!\n    newTemplateId: PHID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Change the resource template"
            }
          ]
        },
        {
          "description": "Service CRUD and facet bindings",
          "id": "mod-services",
          "name": "services",
          "operations": [
            {
              "description": "Add a new service",
              "errors": [],
              "examples": [],
              "id": "op-add-service",
              "name": "ADD_SERVICE",
              "reducer": "state.services.push({\n    id: action.input.id,\n    title: action.input.title,\n    description: action.input.description || null,\n    serviceGroupId: action.input.serviceGroupId || null,\n    displayOrder: action.input.displayOrder || null,\n    isSetupFormation: action.input.isSetupFormation || false,\n    optionGroupId: action.input.optionGroupId || null,\n    facetBindings: [],\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddServiceInput {\n    id: OID!\n    title: String!\n    description: String\n    serviceGroupId: OID\n    displayOrder: Int\n    isSetupFormation: Boolean\n    optionGroupId: OID\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a new service"
            },
            {
              "description": "Update service fields",
              "errors": [
                {
                  "code": "SERVICE_NOT_FOUND",
                  "description": "Service with given ID not found",
                  "id": "err-update-service-not-found",
                  "name": "UpdateServiceNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-service",
              "name": "UPDATE_SERVICE",
              "reducer": "const service = state.services.find(s => s.id === action.input.id);\nif (!service) {\n    throw new UpdateServiceNotFoundError(`Service with ID ${action.input.id} not found`);\n}\nif (action.input.title) service.title = action.input.title;\nif (action.input.description !== undefined) service.description = action.input.description || null;\nif (action.input.serviceGroupId !== undefined) service.serviceGroupId = action.input.serviceGroupId || null;\nif (action.input.displayOrder !== undefined) service.displayOrder = action.input.displayOrder || null;\nif (action.input.isSetupFormation !== undefined && action.input.isSetupFormation !== null) service.isSetupFormation = action.input.isSetupFormation;\nif (action.input.optionGroupId !== undefined) service.optionGroupId = action.input.optionGroupId || null;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateServiceInput {\n    id: OID!\n    title: String\n    description: String\n    serviceGroupId: OID\n    displayOrder: Int\n    isSetupFormation: Boolean\n    optionGroupId: OID\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update service fields"
            },
            {
              "description": "Delete a service",
              "errors": [
                {
                  "code": "SERVICE_NOT_FOUND",
                  "description": "Service with given ID not found",
                  "id": "err-delete-service-not-found",
                  "name": "DeleteServiceNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-delete-service",
              "name": "DELETE_SERVICE",
              "reducer": "const index = state.services.findIndex(s => s.id === action.input.id);\nif (index === -1) {\n    throw new DeleteServiceNotFoundError(`Service with ID ${action.input.id} not found`);\n}\nstate.services.splice(index, 1);\nstate.lastModified = action.input.lastModified;",
              "schema": "input DeleteServiceInput {\n    id: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Delete a service"
            },
            {
              "description": "Add a facet binding to a service",
              "errors": [
                {
                  "code": "SERVICE_NOT_FOUND",
                  "description": "Service with given ID not found",
                  "id": "err-add-fb-service-not-found",
                  "name": "AddFacetBindingServiceNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-facet-binding",
              "name": "ADD_FACET_BINDING",
              "reducer": "const service = state.services.find(s => s.id === action.input.serviceId);\nif (!service) {\n    throw new AddFacetBindingServiceNotFoundError(`Service with ID ${action.input.serviceId} not found`);\n}\nservice.facetBindings.push({\n    id: action.input.bindingId,\n    facetName: action.input.facetName,\n    facetType: action.input.facetType,\n    supportedOptions: action.input.supportedOptions,\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddFacetBindingInput {\n    serviceId: OID!\n    bindingId: OID!\n    facetName: String!\n    facetType: PHID!\n    supportedOptions: [OID!]!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a facet binding to a service"
            },
            {
              "description": "Remove a facet binding from a service",
              "errors": [
                {
                  "code": "SERVICE_NOT_FOUND",
                  "description": "Service with given ID not found",
                  "id": "err-remove-fb-service-not-found",
                  "name": "RemoveFacetBindingServiceNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-facet-binding",
              "name": "REMOVE_FACET_BINDING",
              "reducer": "const service = state.services.find(s => s.id === action.input.serviceId);\nif (!service) {\n    throw new RemoveFacetBindingServiceNotFoundError(`Service with ID ${action.input.serviceId} not found`);\n}\nconst bindingIndex = service.facetBindings.findIndex(fb => fb.id === action.input.bindingId);\nif (bindingIndex !== -1) {\n    service.facetBindings.splice(bindingIndex, 1);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveFacetBindingInput {\n    serviceId: OID!\n    bindingId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove a facet binding from a service"
            }
          ]
        },
        {
          "description": "Subscription tiers, service levels, usage limits, billing cycles, and discounts",
          "id": "mod-tiers",
          "name": "tiers",
          "operations": [
            {
              "description": "Add a subscription tier",
              "errors": [],
              "examples": [],
              "id": "op-add-tier",
              "name": "ADD_TIER",
              "reducer": "state.tiers.push({\n    id: action.input.id,\n    name: action.input.name,\n    description: action.input.description || null,\n    isCustomPricing: action.input.isCustomPricing || false,\n    pricingMode: null,\n    pricing: {\n        amount: action.input.amount || null,\n        currency: action.input.currency,\n    },\n    defaultBillingCycle: null,\n    billingCycleDiscounts: [],\n    serviceLevels: [],\n    usageLimits: [],\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddTierInput {\n    id: OID!\n    name: String!\n    description: String\n    amount: Amount_Money\n    currency: Currency!\n    isCustomPricing: Boolean\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a subscription tier"
            },
            {
              "description": "Update tier metadata",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-update-tier-not-found",
                  "name": "UpdateTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-tier",
              "name": "UPDATE_TIER",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.id);\nif (!tier) {\n    throw new UpdateTierNotFoundError(`Tier with ID ${action.input.id} not found`);\n}\nif (action.input.name) tier.name = action.input.name;\nif (action.input.description !== undefined) tier.description = action.input.description || null;\nif (action.input.isCustomPricing !== undefined && action.input.isCustomPricing !== null) tier.isCustomPricing = action.input.isCustomPricing;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateTierInput {\n    id: OID!\n    name: String\n    description: String\n    isCustomPricing: Boolean\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update tier metadata"
            },
            {
              "description": "Update tier base pricing",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-update-tier-pricing-not-found",
                  "name": "UpdateTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-tier-pricing",
              "name": "UPDATE_TIER_PRICING",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new UpdateTierPricingNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\nif (action.input.amount !== undefined) tier.pricing.amount = action.input.amount || null;\nif (action.input.currency) tier.pricing.currency = action.input.currency;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateTierPricingInput {\n    tierId: OID!\n    amount: Amount_Money\n    currency: Currency\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update tier base pricing"
            },
            {
              "description": "Delete a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-delete-tier-not-found",
                  "name": "DeleteTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-delete-tier",
              "name": "DELETE_TIER",
              "reducer": "const index = state.tiers.findIndex(t => t.id === action.input.id);\nif (index === -1) {\n    throw new DeleteTierNotFoundError(`Tier with ID ${action.input.id} not found`);\n}\nstate.tiers.splice(index, 1);\nstate.lastModified = action.input.lastModified;",
              "schema": "input DeleteTierInput {\n    id: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Delete a tier"
            },
            {
              "description": "Bind a service level to a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-add-sl-tier-not-found",
                  "name": "AddServiceLevelTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-service-level",
              "name": "ADD_SERVICE_LEVEL",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new AddServiceLevelTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\ntier.serviceLevels.push({\n    id: action.input.serviceLevelId,\n    serviceId: action.input.serviceId,\n    level: action.input.level,\n    customValue: action.input.customValue || null,\n    optionGroupId: action.input.optionGroupId || null,\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddServiceLevelInput {\n    tierId: OID!\n    serviceLevelId: OID!\n    serviceId: OID!\n    level: ServiceLevel!\n    optionGroupId: OID\n    customValue: String\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Bind a service level to a tier"
            },
            {
              "description": "Update a service level binding",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-update-sl-tier-not-found",
                  "name": "UpdateServiceLevelTierNotFoundError",
                  "template": ""
                },
                {
                  "code": "SERVICE_LEVEL_NOT_FOUND",
                  "description": "Service level binding with given ID not found",
                  "id": "err-update-sl-not-found",
                  "name": "UpdateServiceLevelNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-service-level",
              "name": "UPDATE_SERVICE_LEVEL",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new UpdateServiceLevelTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\nconst sl = tier.serviceLevels.find(s => s.id === action.input.serviceLevelId);\nif (!sl) {\n    throw new UpdateServiceLevelNotFoundError(`Service level with ID ${action.input.serviceLevelId} not found`);\n}\nif (action.input.level) sl.level = action.input.level;\nif (action.input.customValue !== undefined) sl.customValue = action.input.customValue || null;\nif (action.input.optionGroupId !== undefined) sl.optionGroupId = action.input.optionGroupId || null;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateServiceLevelInput {\n    tierId: OID!\n    serviceLevelId: OID!\n    level: ServiceLevel\n    optionGroupId: OID\n    customValue: String\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update a service level binding"
            },
            {
              "description": "Remove a service level from a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-remove-sl-tier-not-found",
                  "name": "RemoveServiceLevelTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-service-level",
              "name": "REMOVE_SERVICE_LEVEL",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new RemoveServiceLevelTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\nconst index = tier.serviceLevels.findIndex(s => s.id === action.input.serviceLevelId);\nif (index !== -1) {\n    tier.serviceLevels.splice(index, 1);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveServiceLevelInput {\n    tierId: OID!\n    serviceLevelId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove a service level from a tier"
            },
            {
              "description": "Add a usage limit to a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-add-ul-tier-not-found",
                  "name": "AddUsageLimitTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-usage-limit",
              "name": "ADD_USAGE_LIMIT",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new AddUsageLimitTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\ntier.usageLimits.push({\n    id: action.input.limitId,\n    serviceId: action.input.serviceId,\n    metric: action.input.metric,\n    unitName: action.input.unitName || null,\n    freeLimit: action.input.freeLimit || null,\n    paidLimit: action.input.paidLimit || null,\n    resetCycle: action.input.resetCycle || null,\n    notes: action.input.notes || null,\n    unitPrice: action.input.unitPrice || null,\n    unitPriceCurrency: action.input.unitPriceCurrency || null,\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddUsageLimitInput {\n    tierId: OID!\n    limitId: OID!\n    serviceId: OID!\n    metric: String!\n    unitName: String\n    freeLimit: Int\n    paidLimit: Int\n    resetCycle: UsageResetCycle\n    notes: String\n    unitPrice: Amount_Money\n    unitPriceCurrency: Currency\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a usage limit to a tier"
            },
            {
              "description": "Update a usage limit",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-update-ul-tier-not-found",
                  "name": "UpdateUsageLimitTierNotFoundError",
                  "template": ""
                },
                {
                  "code": "USAGE_LIMIT_NOT_FOUND",
                  "description": "Usage limit with given ID not found",
                  "id": "err-update-ul-not-found",
                  "name": "UpdateUsageLimitNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-usage-limit",
              "name": "UPDATE_USAGE_LIMIT",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new UpdateUsageLimitTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\nconst ul = tier.usageLimits.find(u => u.id === action.input.limitId);\nif (!ul) {\n    throw new UpdateUsageLimitNotFoundError(`Usage limit with ID ${action.input.limitId} not found`);\n}\nif (action.input.metric) ul.metric = action.input.metric;\nif (action.input.unitName !== undefined) ul.unitName = action.input.unitName || null;\nif (action.input.freeLimit !== undefined) ul.freeLimit = action.input.freeLimit || null;\nif (action.input.paidLimit !== undefined) ul.paidLimit = action.input.paidLimit || null;\nif (action.input.resetCycle !== undefined) ul.resetCycle = action.input.resetCycle || null;\nif (action.input.notes !== undefined) ul.notes = action.input.notes || null;\nif (action.input.unitPrice !== undefined) ul.unitPrice = action.input.unitPrice || null;\nif (action.input.unitPriceCurrency !== undefined) ul.unitPriceCurrency = action.input.unitPriceCurrency || null;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateUsageLimitInput {\n    tierId: OID!\n    limitId: OID!\n    metric: String\n    unitName: String\n    freeLimit: Int\n    paidLimit: Int\n    resetCycle: UsageResetCycle\n    notes: String\n    unitPrice: Amount_Money\n    unitPriceCurrency: Currency\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update a usage limit"
            },
            {
              "description": "Remove a usage limit from a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-remove-ul-tier-not-found",
                  "name": "RemoveUsageLimitTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-usage-limit",
              "name": "REMOVE_USAGE_LIMIT",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new RemoveUsageLimitTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\nconst index = tier.usageLimits.findIndex(u => u.id === action.input.limitId);\nif (index !== -1) {\n    tier.usageLimits.splice(index, 1);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveUsageLimitInput {\n    tierId: OID!\n    limitId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove a usage limit from a tier"
            },
            {
              "description": "Set the default billing cycle for a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-set-tbc-tier-not-found",
                  "name": "SetTierDefaultBillingCycleTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-tier-default-billing-cycle",
              "name": "SET_TIER_DEFAULT_BILLING_CYCLE",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new SetTierDefaultBillingCycleTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\ntier.defaultBillingCycle = action.input.defaultBillingCycle;\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetTierDefaultBillingCycleInput {\n    tierId: OID!\n    defaultBillingCycle: BillingCycle!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set the default billing cycle for a tier"
            },
            {
              "description": "Set billing cycle discounts for a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-set-tbcd-tier-not-found",
                  "name": "SetTierBillingCycleDiscountsTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-tier-billing-cycle-discounts",
              "name": "SET_TIER_BILLING_CYCLE_DISCOUNTS",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new SetTierBillingCycleDiscountsTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\ntier.billingCycleDiscounts = action.input.discounts.map(d => ({\n    billingCycle: d.billingCycle,\n    discountRule: {\n        discountType: d.discountRule.discountType,\n        discountValue: d.discountRule.discountValue,\n    },\n}));\nstate.lastModified = action.input.lastModified;",
              "schema": "input DiscountRuleInput {\n    discountType: DiscountType!\n    discountValue: Float!\n}\n\ninput BillingCycleDiscountInput {\n    billingCycle: BillingCycle!\n    discountRule: DiscountRuleInput!\n}\n\ninput SetTierBillingCycleDiscountsInput {\n    tierId: OID!\n    discounts: [BillingCycleDiscountInput!]!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set billing cycle discounts for a tier"
            },
            {
              "description": "Set the pricing mode for a tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "Tier with given ID not found",
                  "id": "err-set-tpm-tier-not-found",
                  "name": "SetTierPricingModeTierNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-tier-pricing-mode",
              "name": "SET_TIER_PRICING_MODE",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.tierId);\nif (!tier) {\n    throw new SetTierPricingModeTierNotFoundError(`Tier with ID ${action.input.tierId} not found`);\n}\ntier.pricingMode = action.input.pricingMode;\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetTierPricingModeInput {\n    tierId: OID!\n    pricingMode: TierPricingMode!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set the pricing mode for a tier"
            }
          ]
        },
        {
          "description": "Add-on option groups with standalone and tier-dependent pricing",
          "id": "mod-option-groups",
          "name": "option-groups",
          "operations": [
            {
              "description": "Add an option group",
              "errors": [],
              "examples": [],
              "id": "op-add-option-group",
              "name": "ADD_OPTION_GROUP",
              "reducer": "state.optionGroups.push({\n    id: action.input.id,\n    name: action.input.name,\n    description: action.input.description || null,\n    isAddOn: action.input.isAddOn,\n    defaultSelected: action.input.defaultSelected,\n    pricingMode: null,\n    standalonePricing: null,\n    tierDependentPricing: null,\n    costType: action.input.costType || null,\n    availableBillingCycles: action.input.availableBillingCycles || [],\n    billingCycleDiscounts: [],\n    discountMode: null,\n    price: action.input.price || null,\n    currency: action.input.currency || null,\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddOptionGroupInput {\n    id: OID!\n    name: String!\n    description: String\n    isAddOn: Boolean!\n    defaultSelected: Boolean!\n    costType: GroupCostType\n    availableBillingCycles: [BillingCycle!]\n    price: Amount_Money\n    currency: Currency\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add an option group"
            },
            {
              "description": "Update option group fields",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-update-og-not-found",
                  "name": "UpdateOptionGroupNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-option-group",
              "name": "UPDATE_OPTION_GROUP",
              "reducer": "const og = state.optionGroups.find(g => g.id === action.input.id);\nif (!og) {\n    throw new UpdateOptionGroupNotFoundError(`Option group with ID ${action.input.id} not found`);\n}\nif (action.input.name) og.name = action.input.name;\nif (action.input.description !== undefined) og.description = action.input.description || null;\nif (action.input.isAddOn !== undefined && action.input.isAddOn !== null) og.isAddOn = action.input.isAddOn;\nif (action.input.defaultSelected !== undefined && action.input.defaultSelected !== null) og.defaultSelected = action.input.defaultSelected;\nif (action.input.costType !== undefined) og.costType = action.input.costType || null;\nif (action.input.availableBillingCycles) og.availableBillingCycles = action.input.availableBillingCycles;\nif (action.input.price !== undefined) og.price = action.input.price || null;\nif (action.input.currency !== undefined) og.currency = action.input.currency || null;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateOptionGroupInput {\n    id: OID!\n    name: String\n    description: String\n    isAddOn: Boolean\n    defaultSelected: Boolean\n    costType: GroupCostType\n    availableBillingCycles: [BillingCycle!]\n    price: Amount_Money\n    currency: Currency\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update option group fields"
            },
            {
              "description": "Delete an option group",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-delete-og-not-found",
                  "name": "DeleteOptionGroupNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-delete-option-group",
              "name": "DELETE_OPTION_GROUP",
              "reducer": "const index = state.optionGroups.findIndex(g => g.id === action.input.id);\nif (index === -1) {\n    throw new DeleteOptionGroupNotFoundError(`Option group with ID ${action.input.id} not found`);\n}\nstate.optionGroups.splice(index, 1);\nstate.lastModified = action.input.lastModified;",
              "schema": "input DeleteOptionGroupInput {\n    id: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Delete an option group"
            },
            {
              "description": "Set standalone pricing for an option group",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-set-ogsp-not-found",
                  "name": "SetOptionGroupStandalonePricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-option-group-standalone-pricing",
              "name": "SET_OPTION_GROUP_STANDALONE_PRICING",
              "reducer": "const og = state.optionGroups.find(g => g.id === action.input.optionGroupId);\nif (!og) {\n    throw new SetOptionGroupStandalonePricingNotFoundError(`Option group with ID ${action.input.optionGroupId} not found`);\n}\nog.pricingMode = \"STANDALONE\";\nog.standalonePricing = {\n    setupCost: action.input.setupCost ? {\n        amount: action.input.setupCost.amount,\n        currency: action.input.setupCost.currency,\n        discount: action.input.setupCost.discount ? {\n            discountType: action.input.setupCost.discount.discountType,\n            discountValue: action.input.setupCost.discount.discountValue,\n        } : null,\n    } : null,\n    recurringPricing: action.input.recurringPricing.map(rp => ({\n        id: rp.id,\n        billingCycle: rp.billingCycle,\n        amount: rp.amount,\n        currency: rp.currency,\n        discount: rp.discount ? {\n            discountType: rp.discount.discountType,\n            discountValue: rp.discount.discountValue,\n        } : null,\n    })),\n};\nif (action.input.billingCycleDiscounts) {\n    og.billingCycleDiscounts = action.input.billingCycleDiscounts.map(d => ({\n        billingCycle: d.billingCycle,\n        discountRule: {\n            discountType: d.discountRule.discountType,\n            discountValue: d.discountRule.discountValue,\n        },\n    }));\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RecurringPriceOptionInput {\n    id: OID!\n    billingCycle: BillingCycle!\n    amount: Amount_Money!\n    currency: Currency!\n    discount: DiscountRuleInput\n}\n\ninput SetupCostInput {\n    amount: Amount_Money!\n    currency: Currency!\n    discount: DiscountRuleInput\n}\n\ninput SetOptionGroupStandalonePricingInput {\n    optionGroupId: OID!\n    setupCost: SetupCostInput\n    recurringPricing: [RecurringPriceOptionInput!]!\n    billingCycleDiscounts: [BillingCycleDiscountInput!]\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set standalone pricing for an option group"
            },
            {
              "description": "Add tier-dependent pricing to an option group",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-add-ogtp-not-found",
                  "name": "AddOptionGroupTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-option-group-tier-pricing",
              "name": "ADD_OPTION_GROUP_TIER_PRICING",
              "reducer": "const og = state.optionGroups.find(g => g.id === action.input.optionGroupId);\nif (!og) {\n    throw new AddOptionGroupTierPricingNotFoundError(`Option group with ID ${action.input.optionGroupId} not found`);\n}\nog.pricingMode = \"TIER_DEPENDENT\";\nif (!og.tierDependentPricing) {\n    og.tierDependentPricing = [];\n}\nog.tierDependentPricing.push({\n    id: action.input.tierPricingId,\n    tierId: action.input.tierId,\n    setupCost: action.input.setupCost ? {\n        amount: action.input.setupCost.amount,\n        currency: action.input.setupCost.currency,\n        discount: action.input.setupCost.discount ? {\n            discountType: action.input.setupCost.discount.discountType,\n            discountValue: action.input.setupCost.discount.discountValue,\n        } : null,\n    } : null,\n    setupCostDiscounts: (action.input.setupCostDiscounts || []).map(d => ({\n        billingCycle: d.billingCycle,\n        discountRule: {\n            discountType: d.discountRule.discountType,\n            discountValue: d.discountRule.discountValue,\n        },\n    })),\n    recurringPricing: action.input.recurringPricing.map(rp => ({\n        id: rp.id,\n        billingCycle: rp.billingCycle,\n        amount: rp.amount,\n        currency: rp.currency,\n        discount: rp.discount ? {\n            discountType: rp.discount.discountType,\n            discountValue: rp.discount.discountValue,\n        } : null,\n    })),\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddOptionGroupTierPricingInput {\n    optionGroupId: OID!\n    tierPricingId: OID!\n    tierId: OID!\n    setupCost: SetupCostInput\n    setupCostDiscounts: [BillingCycleDiscountInput!]\n    recurringPricing: [RecurringPriceOptionInput!]!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add tier-dependent pricing to an option group"
            },
            {
              "description": "Update tier-dependent pricing for an option group",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-update-ogtp-not-found",
                  "name": "UpdateOptionGroupTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-option-group-tier-pricing",
              "name": "UPDATE_OPTION_GROUP_TIER_PRICING",
              "reducer": "const og = state.optionGroups.find(g => g.id === action.input.optionGroupId);\nif (!og) {\n    throw new UpdateOptionGroupTierPricingNotFoundError(`Option group with ID ${action.input.optionGroupId} not found`);\n}\nconst tp = og.tierDependentPricing?.find(t => t.tierId === action.input.tierId);\nif (tp) {\n    if (action.input.setupCost !== undefined) {\n        tp.setupCost = action.input.setupCost ? {\n            amount: action.input.setupCost.amount,\n            currency: action.input.setupCost.currency,\n            discount: action.input.setupCost.discount ? {\n                discountType: action.input.setupCost.discount.discountType,\n                discountValue: action.input.setupCost.discount.discountValue,\n            } : null,\n        } : null;\n    }\n    if (action.input.setupCostDiscounts !== undefined && action.input.setupCostDiscounts !== null) {\n        tp.setupCostDiscounts = action.input.setupCostDiscounts.map(d => ({\n            billingCycle: d.billingCycle,\n            discountRule: {\n                discountType: d.discountRule.discountType,\n                discountValue: d.discountRule.discountValue,\n            },\n        }));\n    }\n    if (action.input.recurringPricing) {\n        tp.recurringPricing = action.input.recurringPricing.map(rp => ({\n            id: rp.id,\n            billingCycle: rp.billingCycle,\n            amount: rp.amount,\n            currency: rp.currency,\n            discount: rp.discount ? {\n                discountType: rp.discount.discountType,\n                discountValue: rp.discount.discountValue,\n            } : null,\n        }));\n    }\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateOptionGroupTierPricingInput {\n    optionGroupId: OID!\n    tierId: OID!\n    setupCost: SetupCostInput\n    setupCostDiscounts: [BillingCycleDiscountInput!]\n    recurringPricing: [RecurringPriceOptionInput!]\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update tier-dependent pricing for an option group"
            },
            {
              "description": "Remove tier-dependent pricing from an option group",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-remove-ogtp-not-found",
                  "name": "RemoveOptionGroupTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-option-group-tier-pricing",
              "name": "REMOVE_OPTION_GROUP_TIER_PRICING",
              "reducer": "const og = state.optionGroups.find(g => g.id === action.input.optionGroupId);\nif (!og) {\n    throw new RemoveOptionGroupTierPricingNotFoundError(`Option group with ID ${action.input.optionGroupId} not found`);\n}\nif (og.tierDependentPricing) {\n    const index = og.tierDependentPricing.findIndex(t => t.tierId === action.input.tierId);\n    if (index !== -1) {\n        og.tierDependentPricing.splice(index, 1);\n    }\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveOptionGroupTierPricingInput {\n    optionGroupId: OID!\n    tierId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove tier-dependent pricing from an option group"
            },
            {
              "description": "Set the discount mode for an option group",
              "errors": [
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "Option group with given ID not found",
                  "id": "err-set-ogdm-not-found",
                  "name": "SetOptionGroupDiscountModeNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-option-group-discount-mode",
              "name": "SET_OPTION_GROUP_DISCOUNT_MODE",
              "reducer": "const og = state.optionGroups.find(g => g.id === action.input.optionGroupId);\nif (!og) {\n    throw new SetOptionGroupDiscountModeNotFoundError(`Option group with ID ${action.input.optionGroupId} not found`);\n}\nog.discountMode = action.input.discountMode;\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetOptionGroupDiscountModeInput {\n    optionGroupId: OID!\n    discountMode: DiscountMode!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set the discount mode for an option group"
            }
          ]
        },
        {
          "description": "Service groups with group-level tier pricing, setup costs, and recurring price options",
          "id": "mod-service-groups",
          "name": "service-groups",
          "operations": [
            {
              "description": "Add a service group",
              "errors": [],
              "examples": [],
              "id": "op-add-service-group",
              "name": "ADD_SERVICE_GROUP",
              "reducer": "state.serviceGroups.push({\n    id: action.input.id,\n    name: action.input.name,\n    description: action.input.description || null,\n    billingCycle: action.input.billingCycle,\n    displayOrder: action.input.displayOrder || null,\n    discountMode: action.input.discountMode || null,\n    tierPricing: [],\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddServiceGroupInput {\n    id: OID!\n    name: String!\n    description: String\n    billingCycle: BillingCycle!\n    displayOrder: Int\n    discountMode: DiscountMode\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a service group"
            },
            {
              "description": "Update service group fields",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-update-sg-not-found",
                  "name": "UpdateServiceGroupNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-service-group",
              "name": "UPDATE_SERVICE_GROUP",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.id);\nif (!sg) {\n    throw new UpdateServiceGroupNotFoundError(`Service group with ID ${action.input.id} not found`);\n}\nif (action.input.name) sg.name = action.input.name;\nif (action.input.description !== undefined) sg.description = action.input.description || null;\nif (action.input.billingCycle) sg.billingCycle = action.input.billingCycle;\nif (action.input.displayOrder !== undefined) sg.displayOrder = action.input.displayOrder || null;\nif (action.input.discountMode !== undefined) sg.discountMode = action.input.discountMode || null;\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateServiceGroupInput {\n    id: OID!\n    name: String\n    description: String\n    billingCycle: BillingCycle\n    displayOrder: Int\n    discountMode: DiscountMode\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update service group fields"
            },
            {
              "description": "Delete a service group",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-delete-sg-not-found",
                  "name": "DeleteServiceGroupNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-delete-service-group",
              "name": "DELETE_SERVICE_GROUP",
              "reducer": "const index = state.serviceGroups.findIndex(g => g.id === action.input.id);\nif (index === -1) {\n    throw new DeleteServiceGroupNotFoundError(`Service group with ID ${action.input.id} not found`);\n}\nstate.serviceGroups.splice(index, 1);\nstate.lastModified = action.input.lastModified;",
              "schema": "input DeleteServiceGroupInput {\n    id: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Delete a service group"
            },
            {
              "description": "Reorder service groups",
              "errors": [],
              "examples": [],
              "id": "op-reorder-service-groups",
              "name": "REORDER_SERVICE_GROUPS",
              "reducer": "const ordered = [];\nfor (const id of action.input.order) {\n    const sg = state.serviceGroups.find(g => g.id === id);\n    if (sg) {\n        ordered.push(sg);\n    }\n}\nstate.serviceGroups = ordered;\nstate.lastModified = action.input.lastModified;",
              "schema": "input ReorderServiceGroupsInput {\n    order: [OID!]!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Reorder service groups"
            },
            {
              "description": "Add tier pricing to a service group",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-add-sgtp-not-found",
                  "name": "AddServiceGroupTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-service-group-tier-pricing",
              "name": "ADD_SERVICE_GROUP_TIER_PRICING",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new AddServiceGroupTierPricingNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nsg.tierPricing.push({\n    id: action.input.tierPricingId,\n    tierId: action.input.tierId,\n    setupCostsPerCycle: [],\n    recurringPricing: [],\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddServiceGroupTierPricingInput {\n    serviceGroupId: OID!\n    tierPricingId: OID!\n    tierId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add tier pricing to a service group"
            },
            {
              "description": "Set setup cost for a service group tier",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-set-sgsc-not-found",
                  "name": "SetServiceGroupSetupCostNotFoundError",
                  "template": ""
                },
                {
                  "code": "TIER_PRICING_NOT_FOUND",
                  "description": "Tier pricing entry not found for given service group and tier",
                  "id": "err-set-sgsc-tier-not-found",
                  "name": "SetServiceGroupSetupCostTierPricingNotFoundError",
                  "template": ""
                },
                {
                  "code": "INVALID_SETUP_DISCOUNT",
                  "description": "Percentage discount exceeds 100 or discount value is negative",
                  "id": "err-set-sgsc-invalid-discount",
                  "name": "InvalidSetupDiscountError",
                  "template": ""
                },
                {
                  "code": "INCOMPLETE_SETUP_DISCOUNT",
                  "description": "Both discountType and discountValue must be provided together or both omitted",
                  "id": "err-set-sgsc-incomplete-discount",
                  "name": "IncompleteSetupDiscountError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-service-group-setup-cost",
              "name": "SET_SERVICE_GROUP_SETUP_COST",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new SetServiceGroupSetupCostNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nconst tp = sg.tierPricing.find(t => t.tierId === action.input.tierId);\nif (!tp) {\n    throw new SetServiceGroupSetupCostTierPricingNotFoundError(`Tier pricing for tier ${action.input.tierId} not found in service group ${action.input.serviceGroupId}`);\n}\nconst hasDiscountType = action.input.discountType !== undefined && action.input.discountType !== null;\nconst hasDiscountValue = action.input.discountValue !== undefined && action.input.discountValue !== null;\nif (hasDiscountType !== hasDiscountValue) {\n    throw new IncompleteSetupDiscountError(\"Both discountType and discountValue must be provided together or both omitted\");\n}\nif (hasDiscountValue && action.input.discountValue < 0) {\n    throw new InvalidSetupDiscountError(\"Discount value cannot be negative\");\n}\nif (hasDiscountType && action.input.discountType === \"PERCENTAGE\" && action.input.discountValue > 100) {\n    throw new InvalidSetupDiscountError(\"Percentage discount cannot exceed 100\");\n}\nconst existingIndex = tp.setupCostsPerCycle.findIndex(sc => sc.billingCycle === sg.billingCycle);\nconst setupCost = {\n    id: `${action.input.serviceGroupId}-${action.input.tierId}-setup`,\n    billingCycle: sg.billingCycle,\n    amount: action.input.amount,\n    currency: action.input.currency,\n    discount: hasDiscountType && hasDiscountValue ? {\n        discountType: action.input.discountType,\n        discountValue: action.input.discountValue,\n    } : null,\n};\nif (existingIndex !== -1) {\n    tp.setupCostsPerCycle[existingIndex] = setupCost;\n} else {\n    tp.setupCostsPerCycle.push(setupCost);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input SetServiceGroupSetupCostInput {\n    serviceGroupId: OID!\n    tierId: OID!\n    amount: Amount_Money!\n    currency: Currency!\n    discountType: DiscountType\n    discountValue: Float\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Set setup cost for a service group tier"
            },
            {
              "description": "Remove setup cost from a service group tier",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-remove-sgsc-not-found",
                  "name": "RemoveServiceGroupSetupCostNotFoundError",
                  "template": ""
                },
                {
                  "code": "TIER_PRICING_NOT_FOUND",
                  "description": "Tier pricing entry not found for given service group and tier",
                  "id": "err-remove-sgsc-tier-not-found",
                  "name": "RemoveServiceGroupSetupCostTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-service-group-setup-cost",
              "name": "REMOVE_SERVICE_GROUP_SETUP_COST",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new RemoveServiceGroupSetupCostNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nconst tp = sg.tierPricing.find(t => t.tierId === action.input.tierId);\nif (!tp) {\n    throw new RemoveServiceGroupSetupCostTierPricingNotFoundError(`Tier pricing for tier ${action.input.tierId} not found in service group ${action.input.serviceGroupId}`);\n}\ntp.setupCostsPerCycle = [];\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveServiceGroupSetupCostInput {\n    serviceGroupId: OID!\n    tierId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove setup cost from a service group tier"
            },
            {
              "description": "Add a recurring price option to a service group tier",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-add-rpo-sg-not-found",
                  "name": "AddRecurringPriceOptionServiceGroupNotFoundError",
                  "template": ""
                },
                {
                  "code": "TIER_PRICING_NOT_FOUND",
                  "description": "Tier pricing entry not found for given service group and tier",
                  "id": "err-add-rpo-tp-not-found",
                  "name": "AddRecurringPriceOptionTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-add-recurring-price-option",
              "name": "ADD_RECURRING_PRICE_OPTION",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new AddRecurringPriceOptionServiceGroupNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nconst tp = sg.tierPricing.find(t => t.tierId === action.input.tierId);\nif (!tp) {\n    throw new AddRecurringPriceOptionTierPricingNotFoundError(`Tier pricing for tier ${action.input.tierId} not found in service group ${action.input.serviceGroupId}`);\n}\ntp.recurringPricing.push({\n    id: action.input.priceOptionId,\n    billingCycle: action.input.billingCycle,\n    amount: action.input.amount,\n    currency: action.input.currency,\n    discount: null,\n});\nstate.lastModified = action.input.lastModified;",
              "schema": "input AddRecurringPriceOptionInput {\n    serviceGroupId: OID!\n    tierId: OID!\n    priceOptionId: OID!\n    billingCycle: BillingCycle!\n    amount: Amount_Money!\n    currency: Currency!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Add a recurring price option to a service group tier"
            },
            {
              "description": "Update a recurring price option",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-update-rpo-sg-not-found",
                  "name": "UpdateRecurringPriceOptionServiceGroupNotFoundError",
                  "template": ""
                },
                {
                  "code": "TIER_PRICING_NOT_FOUND",
                  "description": "Tier pricing entry not found for given service group and tier",
                  "id": "err-update-rpo-tp-not-found",
                  "name": "UpdateRecurringPriceOptionTierPricingNotFoundError",
                  "template": ""
                },
                {
                  "code": "PRICE_OPTION_NOT_FOUND",
                  "description": "Recurring price option with given ID not found",
                  "id": "err-update-rpo-not-found",
                  "name": "UpdateRecurringPriceOptionNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-update-recurring-price-option",
              "name": "UPDATE_RECURRING_PRICE_OPTION",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new UpdateRecurringPriceOptionServiceGroupNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nconst tp = sg.tierPricing.find(t => t.tierId === action.input.tierId);\nif (!tp) {\n    throw new UpdateRecurringPriceOptionTierPricingNotFoundError(`Tier pricing for tier ${action.input.tierId} not found in service group ${action.input.serviceGroupId}`);\n}\nconst rpo = tp.recurringPricing.find(r => r.id === action.input.priceOptionId);\nif (!rpo) {\n    throw new UpdateRecurringPriceOptionNotFoundError(`Recurring price option with ID ${action.input.priceOptionId} not found`);\n}\nif (action.input.billingCycle) rpo.billingCycle = action.input.billingCycle;\nif (action.input.amount !== undefined) rpo.amount = action.input.amount;\nif (action.input.currency) rpo.currency = action.input.currency;\nif (action.input.discount !== undefined) {\n    rpo.discount = action.input.discount ? {\n        discountType: action.input.discount.discountType,\n        discountValue: action.input.discount.discountValue,\n    } : null;\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input UpdateRecurringPriceOptionInput {\n    serviceGroupId: OID!\n    tierId: OID!\n    priceOptionId: OID!\n    billingCycle: BillingCycle\n    amount: Amount_Money\n    currency: Currency\n    discount: DiscountRuleInput\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Update a recurring price option"
            },
            {
              "description": "Remove a recurring price option",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-remove-rpo-sg-not-found",
                  "name": "RemoveRecurringPriceOptionServiceGroupNotFoundError",
                  "template": ""
                },
                {
                  "code": "TIER_PRICING_NOT_FOUND",
                  "description": "Tier pricing entry not found for given service group and tier",
                  "id": "err-remove-rpo-tp-not-found",
                  "name": "RemoveRecurringPriceOptionTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-recurring-price-option",
              "name": "REMOVE_RECURRING_PRICE_OPTION",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new RemoveRecurringPriceOptionServiceGroupNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nconst tp = sg.tierPricing.find(t => t.tierId === action.input.tierId);\nif (!tp) {\n    throw new RemoveRecurringPriceOptionTierPricingNotFoundError(`Tier pricing for tier ${action.input.tierId} not found in service group ${action.input.serviceGroupId}`);\n}\nconst index = tp.recurringPricing.findIndex(r => r.id === action.input.priceOptionId);\nif (index !== -1) {\n    tp.recurringPricing.splice(index, 1);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveRecurringPriceOptionInput {\n    serviceGroupId: OID!\n    tierId: OID!\n    priceOptionId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove a recurring price option"
            },
            {
              "description": "Remove all tier pricing from a service group",
              "errors": [
                {
                  "code": "SERVICE_GROUP_NOT_FOUND",
                  "description": "Service group with given ID not found",
                  "id": "err-remove-sgtp-not-found",
                  "name": "RemoveServiceGroupTierPricingNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-remove-service-group-tier-pricing",
              "name": "REMOVE_SERVICE_GROUP_TIER_PRICING",
              "reducer": "const sg = state.serviceGroups.find(g => g.id === action.input.serviceGroupId);\nif (!sg) {\n    throw new RemoveServiceGroupTierPricingNotFoundError(`Service group with ID ${action.input.serviceGroupId} not found`);\n}\nconst index = sg.tierPricing.findIndex(t => t.tierId === action.input.tierId);\nif (index !== -1) {\n    sg.tierPricing.splice(index, 1);\n}\nstate.lastModified = action.input.lastModified;",
              "schema": "input RemoveServiceGroupTierPricingInput {\n    serviceGroupId: OID!\n    tierId: OID!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Remove all tier pricing from a service group"
            }
          ]
        },
        {
          "description": "Final configuration state for resolved tier selections and pricing",
          "id": "mod-configuration",
          "name": "configuration",
          "operations": [
            {
              "description": "Write the entire resolved configuration for a selected tier",
              "errors": [
                {
                  "code": "TIER_NOT_FOUND",
                  "description": "selectedTierId does not match any tier in state.tiers",
                  "id": "err-set-config-tier-not-found",
                  "name": "SetConfigTierNotFoundError",
                  "template": ""
                },
                {
                  "code": "OPTION_GROUP_NOT_FOUND",
                  "description": "An optionGroupId in optionGroupConfigs does not exist in state.optionGroups",
                  "id": "err-set-config-og-not-found",
                  "name": "SetConfigOptionGroupNotFoundError",
                  "template": ""
                },
                {
                  "code": "ADD_ON_GROUP_NOT_FOUND",
                  "description": "An optionGroupId in addOnConfigs does not exist in state.optionGroups",
                  "id": "err-set-config-addon-not-found",
                  "name": "SetConfigAddOnGroupNotFoundError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "op-set-final-configuration",
              "name": "SET_FINAL_CONFIGURATION",
              "reducer": "const tier = state.tiers.find(t => t.id === action.input.selectedTierId);\nif (!tier) {\n    throw new SetConfigTierNotFoundError(`Tier with ID ${action.input.selectedTierId} not found`);\n}\nfor (const ogConfig of action.input.optionGroupConfigs) {\n    const og = state.optionGroups.find(g => g.id === ogConfig.optionGroupId);\n    if (!og) {\n        throw new SetConfigOptionGroupNotFoundError(`Option group with ID ${ogConfig.optionGroupId} not found`);\n    }\n}\nfor (const addonConfig of action.input.addOnConfigs) {\n    const og = state.optionGroups.find(g => g.id === addonConfig.optionGroupId);\n    if (!og) {\n        throw new SetConfigAddOnGroupNotFoundError(`Option group (add-on) with ID ${addonConfig.optionGroupId} not found`);\n    }\n}\nconst mapDiscount = (d) => d ? {\n    discountType: d.discountType,\n    discountValue: d.discountValue,\n    originalAmount: d.originalAmount,\n    discountedAmount: d.discountedAmount,\n} : null;\nstate.finalConfiguration = {\n    selectedTierId: action.input.selectedTierId,\n    selectedBillingCycle: action.input.selectedBillingCycle,\n    tierBasePrice: action.input.tierBasePrice || null,\n    tierCurrency: action.input.tierCurrency,\n    tierDiscount: mapDiscount(action.input.tierDiscount),\n    optionGroupConfigs: action.input.optionGroupConfigs.map(ogc => ({\n        id: ogc.id,\n        optionGroupId: ogc.optionGroupId,\n        effectiveBillingCycle: ogc.effectiveBillingCycle,\n        billingCycleOverridden: ogc.billingCycleOverridden,\n        discountStripped: ogc.discountStripped,\n        recurringAmount: ogc.recurringAmount || null,\n        currency: ogc.currency || null,\n        discount: mapDiscount(ogc.discount),\n        setupCost: ogc.setupCost || null,\n        setupCostCurrency: ogc.setupCostCurrency || null,\n        setupCostDiscount: mapDiscount(ogc.setupCostDiscount),\n    })),\n    addOnConfigs: action.input.addOnConfigs.map(ac => ({\n        id: ac.id,\n        optionGroupId: ac.optionGroupId,\n        selectedBillingCycle: ac.selectedBillingCycle,\n        recurringAmount: ac.recurringAmount || null,\n        currency: ac.currency || null,\n        discount: mapDiscount(ac.discount),\n        setupCost: ac.setupCost || null,\n        setupCostCurrency: ac.setupCostCurrency || null,\n        setupCostDiscount: mapDiscount(ac.setupCostDiscount),\n    })),\n    lastModified: action.input.lastModified,\n};",
              "schema": "input ResolvedDiscountInput {\n    discountType: DiscountType!\n    discountValue: Float!\n    originalAmount: Amount_Money!\n    discountedAmount: Amount_Money!\n}\n\ninput FinalOptionGroupConfigInput {\n    id: OID!\n    optionGroupId: OID!\n    effectiveBillingCycle: BillingCycle!\n    billingCycleOverridden: Boolean!\n    discountStripped: Boolean!\n    recurringAmount: Amount_Money\n    currency: Currency\n    discount: ResolvedDiscountInput\n    setupCost: Amount_Money\n    setupCostCurrency: Currency\n    setupCostDiscount: ResolvedDiscountInput\n}\n\ninput FinalAddOnConfigInput {\n    id: OID!\n    optionGroupId: OID!\n    selectedBillingCycle: BillingCycle!\n    recurringAmount: Amount_Money\n    currency: Currency\n    discount: ResolvedDiscountInput\n    setupCost: Amount_Money\n    setupCostCurrency: Currency\n    setupCostDiscount: ResolvedDiscountInput\n}\n\ninput SetFinalConfigurationInput {\n    selectedTierId: OID!\n    selectedBillingCycle: BillingCycle!\n    tierBasePrice: Amount_Money\n    tierCurrency: Currency!\n    tierDiscount: ResolvedDiscountInput\n    optionGroupConfigs: [FinalOptionGroupConfigInput!]!\n    addOnConfigs: [FinalAddOnConfigInput!]!\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Write the entire resolved configuration for a selected tier"
            },
            {
              "description": "Reset final configuration to null (idempotent)",
              "errors": [],
              "examples": [],
              "id": "op-clear-final-configuration",
              "name": "CLEAR_FINAL_CONFIGURATION",
              "reducer": "state.finalConfiguration = null;",
              "schema": "input ClearFinalConfigurationInput {\n    lastModified: DateTime!\n}",
              "scope": "global",
              "template": "Reset final configuration to null (idempotent)"
            }
          ]
        }
      ],
      "state": {
        "global": {
          "examples": [],
          "initialValue": "{\"id\":\"\",\"operatorId\":\"\",\"resourceTemplateId\":null,\"title\":\"\",\"summary\":\"\",\"description\":null,\"thumbnailUrl\":null,\"infoLink\":null,\"status\":\"DRAFT\",\"lastModified\":\"2024-01-01T00:00:00Z\",\"targetAudiences\":[],\"facetTargets\":[],\"serviceGroups\":[],\"services\":[],\"tiers\":[],\"optionGroups\":[],\"finalConfiguration\":null}",
          "schema": "type ServiceOfferingState {\n    id: PHID!\n    operatorId: PHID!\n    resourceTemplateId: PHID\n    title: String!\n    summary: String!\n    description: String\n    thumbnailUrl: URL\n    infoLink: URL\n    status: ServiceStatus!\n    lastModified: DateTime!\n    targetAudiences: [TargetAudience!]!\n    facetTargets: [FacetTarget!]!\n    serviceGroups: [ServiceGroup!]!\n    services: [Service!]!\n    tiers: [ServiceSubscriptionTier!]!\n    optionGroups: [OptionGroup!]!\n    finalConfiguration: FinalConfiguration\n}\n\nenum ServiceStatus {\n    DRAFT\n    COMING_SOON\n    ACTIVE\n    DEPRECATED\n}\n\ntype TargetAudience {\n    id: OID!\n    label: String!\n    color: String\n}\n\ntype FacetTarget {\n    id: OID!\n    categoryKey: String!\n    categoryLabel: String!\n    selectedOptions: [String!]!\n}\n\ntype DiscountRule {\n    discountType: DiscountType!\n    discountValue: Float!\n}\n\nenum DiscountType {\n    PERCENTAGE\n    FLAT_AMOUNT\n}\n\ntype BillingCycleDiscount {\n    billingCycle: BillingCycle!\n    discountRule: DiscountRule!\n}\n\ntype ServiceGroup {\n    id: OID!\n    name: String!\n    description: String\n    billingCycle: BillingCycle!\n    displayOrder: Int\n    discountMode: DiscountMode\n    tierPricing: [ServiceGroupTierPricing!]!\n}\n\ntype ServiceGroupTierPricing {\n    id: OID!\n    tierId: OID!\n    setupCostsPerCycle: [SetupCostPerCycle!]!\n    recurringPricing: [RecurringPriceOption!]!\n}\n\ntype SetupCost {\n    amount: Amount_Money!\n    currency: Currency!\n    discount: DiscountRule\n}\n\ntype SetupCostPerCycle {\n    id: OID!\n    billingCycle: BillingCycle!\n    amount: Amount_Money!\n    currency: Currency!\n    discount: DiscountRule\n}\n\ntype RecurringPriceOption {\n    id: OID!\n    billingCycle: BillingCycle!\n    amount: Amount_Money!\n    currency: Currency!\n    discount: DiscountRule\n}\n\ntype Service {\n    id: OID!\n    title: String!\n    description: String\n    displayOrder: Int\n    serviceGroupId: OID\n    isSetupFormation: Boolean!\n    optionGroupId: OID\n    facetBindings: [ResourceFacetBinding!]!\n}\n\ntype ResourceFacetBinding {\n    id: OID!\n    facetName: String!\n    facetType: PHID!\n    supportedOptions: [OID!]!\n}\n\ntype ServiceSubscriptionTier {\n    id: OID!\n    name: String!\n    description: String\n    isCustomPricing: Boolean!\n    pricingMode: TierPricingMode\n    pricing: ServicePricing!\n    defaultBillingCycle: BillingCycle\n    billingCycleDiscounts: [BillingCycleDiscount!]!\n    serviceLevels: [ServiceLevelBinding!]!\n    usageLimits: [ServiceUsageLimit!]!\n}\n\ntype ServicePricing {\n    amount: Amount_Money\n    currency: Currency!\n}\n\nenum BillingCycle {\n    MONTHLY\n    QUARTERLY\n    SEMI_ANNUAL\n    ANNUAL\n    ONE_TIME\n}\n\ntype ServiceLevelBinding {\n    id: OID!\n    serviceId: OID!\n    level: ServiceLevel!\n    customValue: String\n    optionGroupId: OID\n}\n\nenum ServiceLevel {\n    INCLUDED\n    NOT_INCLUDED\n    OPTIONAL\n    CUSTOM\n    VARIABLE\n    NOT_APPLICABLE\n}\n\ntype ServiceUsageLimit {\n    id: OID!\n    serviceId: OID!\n    metric: String!\n    unitName: String\n    freeLimit: Int\n    paidLimit: Int\n    resetCycle: UsageResetCycle\n    notes: String\n    unitPrice: Amount_Money\n    unitPriceCurrency: Currency\n}\n\nenum UsageResetCycle {\n    NONE\n    HOURLY\n    DAILY\n    WEEKLY\n    MONTHLY\n    QUARTERLY\n    SEMI_ANNUAL\n    ANNUAL\n}\n\ntype OptionGroup {\n    id: OID!\n    name: String!\n    description: String\n    isAddOn: Boolean!\n    defaultSelected: Boolean!\n    pricingMode: AddOnPricingMode\n    standalonePricing: StandalonePricing\n    tierDependentPricing: [OptionGroupTierPricing!]\n    costType: GroupCostType\n    availableBillingCycles: [BillingCycle!]!\n    billingCycleDiscounts: [BillingCycleDiscount!]!\n    discountMode: DiscountMode\n    price: Amount_Money\n    currency: Currency\n}\n\nenum AddOnPricingMode {\n    TIER_DEPENDENT\n    STANDALONE\n}\n\nenum DiscountMode {\n    INHERIT_TIER\n    INDEPENDENT\n}\n\nenum TierPricingMode {\n    CALCULATED\n    MANUAL_OVERRIDE\n}\n\ntype StandalonePricing {\n    setupCost: SetupCost\n    recurringPricing: [RecurringPriceOption!]!\n}\n\ntype OptionGroupTierPricing {\n    id: OID!\n    tierId: OID!\n    setupCost: SetupCost\n    setupCostDiscounts: [BillingCycleDiscount!]!\n    recurringPricing: [RecurringPriceOption!]!\n}\n\nenum GroupCostType {\n    RECURRING\n    SETUP\n}\n\ntype ResolvedDiscount {\n    discountType: DiscountType!\n    discountValue: Float!\n    originalAmount: Amount_Money!\n    discountedAmount: Amount_Money!\n}\n\ntype FinalOptionGroupConfig {\n    id: OID!\n    optionGroupId: OID!\n    effectiveBillingCycle: BillingCycle!\n    billingCycleOverridden: Boolean!\n    discountStripped: Boolean!\n    recurringAmount: Amount_Money\n    currency: Currency\n    discount: ResolvedDiscount\n    setupCost: Amount_Money\n    setupCostCurrency: Currency\n    setupCostDiscount: ResolvedDiscount\n}\n\ntype FinalAddOnConfig {\n    id: OID!\n    optionGroupId: OID!\n    selectedBillingCycle: BillingCycle!\n    recurringAmount: Amount_Money\n    currency: Currency\n    discount: ResolvedDiscount\n    setupCost: Amount_Money\n    setupCostCurrency: Currency\n    setupCostDiscount: ResolvedDiscount\n}\n\ntype FinalConfiguration {\n    selectedTierId: OID!\n    selectedBillingCycle: BillingCycle!\n    tierBasePrice: Amount_Money\n    tierCurrency: Currency!\n    tierDiscount: ResolvedDiscount\n    optionGroupConfigs: [FinalOptionGroupConfig!]!\n    addOnConfigs: [FinalAddOnConfig!]!\n    lastModified: DateTime!\n}"
        },
        "local": {
          "examples": [],
          "initialValue": "",
          "schema": ""
        }
      },
      "version": 1
    }
  ]
}