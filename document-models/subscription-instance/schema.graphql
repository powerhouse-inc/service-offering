scalar Unknown
scalar DateTime
scalar Attachment
scalar Address
scalar Amount_Tokens
scalar EthereumAddress
scalar EmailAddress
scalar Amount_Percentage
scalar Date
scalar URL
scalar Amount_Money
scalar OLabel
scalar Currency
scalar PHID
scalar OID
scalar Amount_Fiat
scalar Amount_Currency
scalar Amount_Crypto
scalar Amount
scalar Upload

type SubscriptionInstanceState {
    customerId: PHID
    customerName: String
    customerEmail: EmailAddress
    customerType: CustomerType
    teamMemberCount: Int
    operatorId: PHID
    operatorName: String
    serviceOfferingId: PHID
    tierId: OID
    tierName: String
    tierPricingOptionId: OID
    tierPrice: Amount_Money
    tierCurrency: Currency
    resource: ResourceDocument
    status: SubscriptionStatus!
    createdAt: DateTime
    activatedSince: DateTime
    pausedSince: DateTime
    expiringSince: DateTime
    renewalDate: DateTime
    cancelledSince: DateTime
    cancellationReason: String
    autoRenew: Boolean!
    operatorNotes: String
    budget: BudgetCategory
    nextBillingDate: DateTime
    projectedBillAmount: Amount_Money
    projectedBillCurrency: Currency
    targetAudienceId: OID
    targetAudienceLabel: String
    services: [Service!]!
    serviceGroups: [ServiceGroup!]!
    selectedOptionGroups: [SelectedOptionGroup!]!
    facetSelections: [SubscriptionFacetSelection!]!
    clientRequests: [ClientRequest!]!
}

enum CustomerType {
    INDIVIDUAL
    TEAM
}

type ServiceGroup {
    id: OID!
    optional: Boolean!
    name: String!
    billingCycle: BillingCycle
    optionGroupId: OID
    displayOrder: Int
    services: [Service!]!
}

type ResourceDocument {
    id: PHID!
    label: String
    thumbnailUrl: URL
}

enum SubscriptionStatus {
    PENDING
    ACTIVE
    PAUSED
    EXPIRING
    CANCELLED
}

type RecurringCost {
    amount: Amount_Money!
    currency: Currency!
    billingCycle: BillingCycle!
    nextBillingDate: DateTime
    lastPaymentDate: DateTime
}

type SetupCost {
    amount: Amount_Money!
    currency: Currency!
    billingDate: DateTime
    paymentDate: DateTime
}

enum BillingCycle {
    MONTHLY
    QUARTERLY
    SEMI_ANNUAL
    ANNUAL
    ONE_TIME
}

type BudgetCategory {
    id: OID!
    label: String!
}

enum ServiceLevel {
    INCLUDED
    NOT_INCLUDED
    OPTIONAL
    CUSTOM
    VARIABLE
    NOT_APPLICABLE
}

type Service {
    id: OID!
    name: String
    description: String
    serviceLevel: ServiceLevel
    customValue: String
    facetLabel: String
    isSetupService: Boolean
    displayOrder: Int
    setupCost: SetupCost
    recurringCost: RecurringCost
    metrics: [ServiceMetric!]!
}

type ServiceMetric {
    id: OID!
    name: String!
    unitName: String!
    freeLimit: Int
    paidLimit: Int
    unitCost: RecurringCost
    currentUsage: Int!
    usageResetPeriod: ResetPeriod
    nextUsageReset: DateTime
}

enum ResetPeriod {
    NONE
    HOURLY
    DAILY
    WEEKLY
    MONTHLY
    QUARTERLY
    SEMI_ANNUAL
    ANNUAL
}

type SelectedOptionGroup {
    id: OID!
    optionGroupId: OID!
    name: String!
    isAddOn: Boolean!
    costType: GroupCostType
    billingCycle: BillingCycle
    price: Amount_Money
    currency: Currency
}

enum GroupCostType {
    RECURRING
    SETUP
}

type SubscriptionFacetSelection {
    id: OID!
    categoryKey: String!
    categoryLabel: String!
    selectedOptions: [String!]!
}

enum RequestType {
    REMOVE_SERVICE
    INCREASE_LIMIT
    REMOVE_OPTION
    GENERAL
}

enum RequestStatus {
    PENDING
    APPROVED
    REJECTED
}

type ClientRequest {
    id: OID!
    type: RequestType!
    status: RequestStatus!
    description: String!
    reason: String
    createdAt: DateTime!
    resolvedAt: DateTime
    operatorResponse: String
    serviceId: OID
    serviceName: String
    metricId: OID
    metricName: String
    requestedValue: Int
    optionGroupId: OID
    optionGroupName: String
}

# Subscription

input InitializeSubscriptionInput {
    customerId: PHID
    customerName: String
    customerEmail: EmailAddress
    customerType: CustomerType
    operatorId: PHID
    operatorName: String
    serviceOfferingId: PHID
    tierId: OID
    tierName: String
    tierPricingOptionId: OID
    tierPrice: Amount_Money
    tierCurrency: Currency
    resourceId: PHID
    resourceLabel: String
    resourceThumbnailUrl: URL
    autoRenew: Boolean
    targetAudienceId: OID
    targetAudienceLabel: String
    projectedBillAmount: Amount_Money
    projectedBillCurrency: Currency
    createdAt: DateTime!
}

input SetResourceDocumentInput {
    resourceId: PHID!
    resourceLabel: String
    resourceThumbnailUrl: URL
}

input UpdateSubscriptionStatusInput {
    status: SubscriptionStatus!
}

input ActivateSubscriptionInput {
    activatedSince: DateTime!
}

input PauseSubscriptionInput {
    pausedSince: DateTime!
}

input SetExpiringInput {
    expiringSince: DateTime!
}

input CancelSubscriptionInput {
    cancelledSince: DateTime!
    cancellationReason: String
}

input ResumeSubscriptionInput {
    timestamp: DateTime!
}

input RenewExpiringSubscriptionInput {
    timestamp: DateTime!
    newRenewalDate: DateTime
}

input SetBudgetCategoryInput {
    budgetId: OID!
    budgetLabel: String!
}

input RemoveBudgetCategoryInput {
    budgetId: OID!
}

input UpdateCustomerInfoInput {
    customerId: PHID
    customerName: String
    customerEmail: EmailAddress
}

input UpdateTierInfoInput {
    tierId: OID
    tierName: String
    tierPricingOptionId: OID
    tierPrice: Amount_Money
    tierCurrency: Currency
}

input SetOperatorNotesInput {
    operatorNotes: String
}

input SetAutoRenewInput {
    autoRenew: Boolean!
}

input SetRenewalDateInput {
    renewalDate: DateTime!
}

input UpdateBillingProjectionInput {
    nextBillingDate: DateTime
    projectedBillAmount: Amount_Money
    projectedBillCurrency: Currency
}

input SetTargetAudienceInput {
    targetAudienceId: OID!
    targetAudienceLabel: String!
}

input RemoveTargetAudienceInput {
    targetAudienceId: OID!
}

# Service

input AddServiceInput {
    serviceId: OID!
    name: String
    description: String
    serviceLevel: ServiceLevel
    customValue: String
    facetLabel: String
    isSetupService: Boolean
    displayOrder: Int
    setupAmount: Amount_Money
    setupCurrency: Currency
    setupBillingDate: DateTime
    setupPaymentDate: DateTime
    recurringAmount: Amount_Money
    recurringCurrency: Currency
    recurringBillingCycle: BillingCycle
    recurringNextBillingDate: DateTime
    recurringLastPaymentDate: DateTime
}

input RemoveServiceInput {
    serviceId: OID!
}

input UpdateServiceSetupCostInput {
    serviceId: OID!
    amount: Amount_Money
    currency: Currency
    billingDate: DateTime
    paymentDate: DateTime
}

input UpdateServiceRecurringCostInput {
    serviceId: OID!
    amount: Amount_Money
    currency: Currency
    billingCycle: BillingCycle
    nextBillingDate: DateTime
    lastPaymentDate: DateTime
}

input ReportSetupPaymentInput {
    serviceId: OID!
    paymentDate: DateTime!
}

input ReportRecurringPaymentInput {
    serviceId: OID!
    paymentDate: DateTime!
}

input UpdateServiceInfoInput {
    serviceId: OID!
    name: String
    description: String
}

input UpdateServiceLevelInput {
    serviceId: OID!
    serviceLevel: ServiceLevel!
}

# Service Group

input AddServiceGroupInput {
    groupId: OID!
    name: String!
    optional: Boolean!
    billingCycle: BillingCycle
    optionGroupId: OID
    displayOrder: Int
}

input RemoveServiceGroupInput {
    groupId: OID!
}

input AddServiceToGroupInput {
    groupId: OID!
    serviceId: OID!
    name: String
    description: String
    serviceLevel: ServiceLevel
    customValue: String
    facetLabel: String
    isSetupService: Boolean
    displayOrder: Int
    setupAmount: Amount_Money
    setupCurrency: Currency
    setupBillingDate: DateTime
    setupPaymentDate: DateTime
    recurringAmount: Amount_Money
    recurringCurrency: Currency
    recurringBillingCycle: BillingCycle
    recurringNextBillingDate: DateTime
    recurringLastPaymentDate: DateTime
}

input RemoveServiceFromGroupInput {
    groupId: OID!
    serviceId: OID!
}

# Metrics

input AddServiceMetricInput {
    serviceId: OID!
    metricId: OID!
    name: String!
    unitName: String!
    freeLimit: Int
    paidLimit: Int
    currentUsage: Int!
    usageResetPeriod: ResetPeriod
    nextUsageReset: DateTime
    unitCostAmount: Amount_Money
    unitCostCurrency: Currency
    unitCostBillingCycle: BillingCycle
    unitCostNextBillingDate: DateTime
    unitCostLastPaymentDate: DateTime
}

input UpdateMetricInput {
    serviceId: OID!
    metricId: OID!
    name: String
    unitName: String
    freeLimit: Int
    paidLimit: Int
    usageResetPeriod: ResetPeriod
    nextUsageReset: DateTime
}

input UpdateMetricUsageInput {
    serviceId: OID!
    metricId: OID!
    currentTime: DateTime!
    currentUsage: Int!
}

input RemoveServiceMetricInput {
    serviceId: OID!
    metricId: OID!
}

input IncrementMetricUsageInput {
    serviceId: OID!
    metricId: OID!
    currentTime: DateTime!
    incrementBy: Int!
}

input DecrementMetricUsageInput {
    serviceId: OID!
    metricId: OID!
    currentTime: DateTime!
    decrementBy: Int!
}

# Customer

input SetCustomerTypeInput {
    customerType: CustomerType!
    teamMemberCount: Int
}

input UpdateTeamMemberCountInput {
    teamMemberCount: Int!
}

# Option Group

input AddSelectedOptionGroupInput {
    id: OID!
    optionGroupId: OID!
    name: String!
    isAddOn: Boolean!
    costType: GroupCostType
    billingCycle: BillingCycle
    price: Amount_Money
    currency: Currency
}

input RemoveSelectedOptionGroupInput {
    id: OID!
}

# Facet

input SetFacetSelectionInput {
    id: OID!
    categoryKey: String!
    categoryLabel: String!
    selectedOptions: [String!]!
}

input RemoveFacetSelectionInput {
    categoryKey: String!
}

# Requests

input CreateClientRequestInput {
    id: OID!
    type: RequestType!
    description: String!
    reason: String
    createdAt: DateTime!
    serviceId: OID
    serviceName: String
    metricId: OID
    metricName: String
    requestedValue: Int
    optionGroupId: OID
    optionGroupName: String
}

input ApproveRequestInput {
    requestId: OID!
    resolvedAt: DateTime!
    operatorResponse: String
}

input RejectRequestInput {
    requestId: OID!
    resolvedAt: DateTime!
    operatorResponse: String
}