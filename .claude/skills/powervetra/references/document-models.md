# Document Models Reference

Comprehensive reference for creating and managing document models in the Powerhouse/Vetra ecosystem. This document covers structure, operations, schema design, reducer implementation, error handling, testing, and the full creation workflow.

---

## Table of Contents

1. [Core Structure](#1-core-structure)
2. [Available Operations (all 37)](#2-available-operations-all-37)
3. [State Schema Design](#3-state-schema-design)
4. [Operation Design](#4-operation-design)
5. [Reducer Implementation](#5-reducer-implementation)
6. [Error Handling](#6-error-handling)
7. [Testing](#7-testing)
8. [Generated Files Rules](#8-generated-files-rules)
9. [Two-Step Modification Process](#9-two-step-modification-process)
10. [Document Model Creation Workflow](#10-document-model-creation-workflow)
11. [Specification Driven Design](#11-specification-driven-design)

---

## 1. Core Structure

A document model is a template for creating documents. It defines the schema and allowed operations for a document type.

### Metadata Fields

- **id**: Unique identifier for the document model (auto-generated by `createDocument`, never set manually)
- **name**: Human-readable name of the document model
- **extension**: File extension associated with documents of this type
- **description**: Description of the document model's purpose
- **author**: Object containing:
  - **name**: Author's name
  - **website**: Author's website URL

### Specifications

Versioned specs containing:

- **version**: Semantic version number
- **changeLog**: History of changes across versions
- **state**: Divided into two scopes:
  - **global**: State shared among all users with document access. Contains `schema`, `initialValue`, and `examples`.
  - **local**: State private to each individual user. Contains `schema`, `initialValue`, and `examples`.

### Modules

Operational modules that group related operations together. Each module contains its own set of operations. Organize related operations into logical modules for clarity and maintainability.

---

## 2. Available Operations (all 37)

These are the operations available for defining and modifying a document model via MCP.

### Header Management (6)

| Operation | Description |
|-----------|-------------|
| `SET_MODEL_NAME` | Set the document model's display name |
| `SET_MODEL_ID` | Set the document model's unique identifier |
| `SET_MODEL_EXTENSION` | Set the file extension for documents of this type |
| `SET_MODEL_DESCRIPTION` | Set the description of the document model |
| `SET_AUTHOR_NAME` | Set the author's name |
| `SET_AUTHOR_WEBSITE` | Set the author's website URL |

### Module Management (5)

| Operation | Description |
|-----------|-------------|
| `ADD_MODULE` | Create a new operational module |
| `SET_MODULE_NAME` | Rename an existing module |
| `SET_MODULE_DESCRIPTION` | Update a module's description |
| `DELETE_MODULE` | Remove a module and its operations |
| `REORDER_MODULES` | Change the ordering of modules |

### Operation Management (9)

| Operation | Description |
|-----------|-------------|
| `ADD_OPERATION` | Add a new operation to a module |
| `SET_OPERATION_NAME` | Rename an existing operation |
| `SET_OPERATION_SCHEMA` | Define input/output GraphQL schemas for an operation |
| `SET_OPERATION_DESCRIPTION` | Update an operation's description |
| `SET_OPERATION_TEMPLATE` | Set a template for the operation |
| `SET_OPERATION_REDUCER` | Set the reducer code for an operation |
| `MOVE_OPERATION` | Move an operation to a different module |
| `DELETE_OPERATION` | Remove an operation |
| `REORDER_MODULE_OPERATIONS` | Change the ordering of operations within a module |

### Operation Error Management (7)

| Operation | Description |
|-----------|-------------|
| `ADD_OPERATION_ERROR` | Define a new error type for an operation |
| `SET_OPERATION_ERROR_CODE` | Update an error's code |
| `SET_OPERATION_ERROR_NAME` | Update an error's name |
| `SET_OPERATION_ERROR_DESCRIPTION` | Update an error's description |
| `SET_OPERATION_ERROR_TEMPLATE` | Set a template for the error |
| `DELETE_OPERATION_ERROR` | Remove an error definition |
| `REORDER_OPERATION_ERRORS` | Change the ordering of errors |

### Operation Example Management (4)

| Operation | Description |
|-----------|-------------|
| `ADD_OPERATION_EXAMPLE` | Add an example for an operation |
| `UPDATE_OPERATION_EXAMPLE` | Update an existing operation example |
| `DELETE_OPERATION_EXAMPLE` | Remove an operation example |
| `REORDER_OPERATION_EXAMPLES` | Change the ordering of examples |

### State Management (6)

| Operation | Description |
|-----------|-------------|
| `SET_STATE_SCHEMA` | Define the GraphQL schema for global or local state |
| `SET_INITIAL_STATE` | Set the initial state value for a scope |
| `ADD_STATE_EXAMPLE` | Add an example state |
| `UPDATE_STATE_EXAMPLE` | Update an existing state example |
| `DELETE_STATE_EXAMPLE` | Remove a state example |
| `REORDER_STATE_EXAMPLES` | Change the ordering of state examples |

### Versioning

**DO NOT USE** -- Versioning operations are not implemented and will fail.

---

## 3. State Schema Design

State schemas are defined in GraphQL and control the structure of document data.

### Scope Selection

- **`scope: "global"`**: State shared among all users with document access. Use for the primary document data.
- **`scope: "local"`**: State private to each individual user. Use for user-specific preferences, UI state, or personal annotations.

### State Type Naming Convention (CRITICAL)

The global state type name MUST follow this exact pattern:

```graphql
type <DocumentModelName>State {
    # fields here
}
```

**DO NOT** append "Global" to the state type name:

```graphql
// WRONG - Do not use "GlobalState" suffix
type TodoListGlobalState {
    todos: [Todo!]!
}

// CORRECT - Use only "State" suffix for global state
type TodoListState {
    todos: [Todo!]!
}

// CORRECT - Use "LocalState" suffix for local scope
type TodoListLocalState {
    localTodos: [Todo!]!
}
```

The code generator expects the type to be named `<DocumentModelName>State`. Using `GlobalState` suffix causes TypeScript compilation errors.

### Schema Design Guidelines

- **Most fields should be optional** to support creating empty documents
- Use required fields (`!`) only when absolutely necessary
- Defaults are handled by operations, not the schema

### Available Scalar Types

| Standard | Custom Identity | Custom Amounts | Custom Specialized |
|----------|----------------|----------------|-------------------|
| `String` | `OID` (Object ID) | `Amount` | `EthereumAddress` |
| `Int` | `PHID` (Powerhouse ID) | `Amount_Tokens` | `EmailAddress` |
| `Float` | `OLabel` | `Amount_Money` | `Date` |
| `Boolean` | | `Amount_Fiat` | `DateTime` |
| | | `Amount_Currency` | `URL` |
| | | `Amount_Crypto` | `Currency` |
| | | `Amount_Percentage` | |

### Arrays and Objects

- **Arrays**: Must be mandatory with non-nullable items: `[ObjectType!]!`
- **Objects in arrays**: Must include an `OID!` field for unique identification
- Include `OLabel` for metadata when relevant

### Input Types

- Reflect user intent with descriptive names
- Use simple, specific fields over complex nested types
- System auto-generates `OID` for new objects (users do not provide manually)

---

## 4. Operation Design

### Principles

- **Descriptive names**: Use clear, intent-revealing names (e.g., `ADD_LINE_ITEM`, `UPDATE_RECIPIENT`, `DELETE_ENTRY`)
- **One operation per user intent**: Separate concerns cleanly. Each operation should represent a single user action.
- **Comprehensive examples**: Include examples for each operation to document expected inputs/outputs
- **Error definitions**: Define specific error types for each operation (see Error Handling section)
- **Logical module grouping**: Organize related operations into modules that represent domains or feature areas

### Input Schema Design

- Input types should include all dynamic values needed by the reducer
- Always include `id: OID!` in inputs that create new entities
- Always include `id: OID!` in inputs that reference existing entities for update/delete
- Include `timestamp: DateTime!` if the operation records when something happened
- Include `createdAt: DateTime!` or similar for creation timestamps
- Computed values must be calculated before dispatching and passed in the input

---

## 5. Reducer Implementation

### Fundamental Rules

Reducers are the core logic of document models. They MUST be:

1. **Pure synchronous functions**: Given the same state and operation, they must always return the same result
2. **Deterministic**: No randomness, no time-dependent values, no external state
3. **Side-effect free**: No API calls, no file I/O, no logging side effects
4. **Synchronous only**: No `async`, no Promises, no callbacks

### How Reducers Work

- Reducer code goes into the `SET_OPERATION_REDUCER` action (no function header needed -- the system wraps it)
- Reducers are wrapped with **Mutative** -- you can mutate the state object directly (no need to return a new state)
- External imports go at the beginning of the actual reducer file in `src/`, not in the reducer code passed to `SET_OPERATION_REDUCER`

### Forbidden in Reducers (Non-Deterministic)

These are strictly forbidden inside reducer code:

- `crypto.randomUUID()`
- `Math.random()`
- `Date.now()`
- `new Date()`
- External API calls or side effects
- Asynchronous functions (`async`/`await`)
- Any non-deterministic function

### Forbidden Patterns

```typescript
// FORBIDDEN - fallback to non-deterministic values
id: action.input.id || crypto.randomUUID();
timestamp: action.input.timestamp || new Date();
```

### Required Pattern

All dynamic values MUST come from action input:

- **IDs**: Include `id: OID!` in input schema, use `action.input.id` in reducer
- **Timestamps**: Include `timestamp: DateTime!` in input schema, use `action.input.timestamp`
- **Computed values**: Calculate before dispatching the action, pass via input

```typescript
// BAD - impure reducer
const newItem = {
  id: crypto.randomUUID(),
  createdAt: new Date(),
};

// GOOD - pure reducer
const newItem = {
  id: action.input.id,
  createdAt: action.input.createdAt,
};
```

### Handling Nullable Input Types

This is a common source of type errors. Pay careful attention:

- Optional input types use `InputMaybe<T>` allowing `null | undefined | T`
- Optional state types use `Maybe<T>` = `T | null`
- If there is no applicable default value, use `|| null`

```typescript
// BAD - Type error with Maybe<string>
amount: action.input.amount,
notes: action.input.notes,

// GOOD - Matches Maybe<T> = T | null
amount: action.input.amount || null,
notes: action.input.notes || [],
```

Use truthy checks when conditionally assigning optional values from input to state:

```typescript
// BAD - Type 'string | null' is not assignable to type 'string'
if (action.input.field !== undefined) entry.field = action.input.field;

// GOOD - use truthy checks
if (action.input.field) state.field = action.input.field;

// GOOD - For booleans use explicit null/undefined checks
if (action.input.field !== undefined && action.input.field !== null)
  state.field = action.input.field;
```

### Reducer Stub Warning (CRITICAL)

After creating a document model and adding it to a drive, reducer files in `src/reducers/` are auto-generated with **placeholder/stub code** that throws "not implemented" errors. You MUST manually implement the actual reducer logic in these files.

Example of generated stub (DO NOT leave like this):

```typescript
export const todoTodoOperations: TodoTodoOperations = {
  addTodoOperation(state, action) {
    // TODO: implement addTodoOperation reducer
    throw new Error("Reducer for 'addTodoOperation' not implemented.");
  },
};
```

### Steps After Creating a Document Model

1. Wait for code generation to complete (files appear in `document-models/<name>/src/reducers/`)
2. Open the reducer file(s) in `src/reducers/<module-name>.ts`
3. Replace the stub implementations with actual reducer logic
4. Import error classes from `../../gen/<module-name>/error.js` if using custom errors
5. Run `npm run tsc` and `npm run lint:fix` to verify implementation

---

## 6. Error Handling

### Error Definition Requirements

Define specific error types for each operation using `ADD_OPERATION_ERROR`. Required fields:

- **code**: Uppercase snake_case (e.g., `"MISSING_ID"`, `"ENTRY_NOT_FOUND"`)
- **name**: PascalCase ending with "Error" (e.g., `"MissingIdError"`, `"EntryNotFoundError"`)
- **description**: Human-readable description of the error condition

Rules:
- Error names MUST end with "Error" for consistency and code generation
- Use specific error types rather than generic validation
- Must use unique error names and IDs

### Unique Error Names Across Operations (CRITICAL)

Error names MUST be globally unique across ALL operations in a document model. Each operation generates its own error class in the `gen/` folder. If the same error name is used in multiple operations, it causes duplicate class definitions and build errors:

```
ERROR: Multiple exports with the same name "TodoNotFoundError"
ERROR: The symbol "TodoNotFoundError" has already been declared
```

```typescript
// BAD - Same error name used in UPDATE_TODO and DELETE_TODO operations
ADD_OPERATION_ERROR for UPDATE_TODO: { errorName: "TodoNotFoundError" }
ADD_OPERATION_ERROR for DELETE_TODO: { errorName: "TodoNotFoundError" }

// GOOD - Unique error names per operation
ADD_OPERATION_ERROR for UPDATE_TODO: { errorName: "UpdateTodoNotFoundError" }
ADD_OPERATION_ERROR for DELETE_TODO: { errorName: "DeleteTodoNotFoundError" }
```

**Naming convention**: Prefix the error name with the operation name to ensure uniqueness:
- `Update<Entity>NotFoundError`
- `Delete<Entity>NotFoundError`
- `Toggle<Entity>NotFoundError`

### Error Usage in Reducers

```typescript
// GOOD - Throw specific errors by name (auto-imported)
if (!action.input.id) {
  throw new MissingIdError("ID is required for operation");
}

if (entryIndex === -1) {
  throw new EntryNotFoundError(`Entry with ID ${action.input.id} not found`);
}

// BAD - Generic Error
throw new Error("Something went wrong");

// BAD - Nested error access
throw new errors.ModuleName.MissingIdError("message");

// BAD - Do not import error classes in the reducer code
import { MissingIdError } from "../../gen/module-name/error.js";

// GOOD - Simply reference the error and it will be imported automatically
throw new MissingIdError("message");
```

### Common Error Patterns

| Pattern | Use Case |
|---------|----------|
| `EntityNotFoundError` | Referenced entity does not exist |
| `DuplicateIdError` | ID already exists when creating new entries |
| `InvalidInputError` | Business logic violations |
| `PermissionDeniedError` | Access control violations |

---

## 7. Testing

### Testing Document Models

- Use `utils.createDocument()` to generate empty test documents
- Use `generateMock(Schema)` to populate inputs with random test values
- Use `reducer(document, action)` to apply operations
- Validate with `isValidDocument(updatedDocument)`

### Test Each Operation Type

- **Add operations**: Verify entity is created and appended to the correct array/collection
- **Update operations**: Find entity by ID, verify partial updates apply correctly, verify unchanged fields remain intact
- **Delete operations**: Verify entity is filtered out by ID, verify other entities remain

### Running Tests

```bash
pnpm run test
# or
npm test
```

---

## 8. Generated Files Rules

### Never Edit Generated Files

**NEVER edit files in `gen/` folders.** These files are auto-generated and will be overwritten on the next code generation cycle. Any manual changes will be lost.

Generated files include:
- TypeScript types
- Action creators
- Reducer scaffolding
- Operation type definitions
- Document specification files
- Error classes

### Files You DO Edit

- `src/reducers/<module-name>.ts` -- Reducer implementations (generated as stubs, must be manually completed)
- Any other files in `src/` that are not in `gen/`

---

## 9. Two-Step Modification Process

For ANY document model changes, you MUST follow this mandatory two-step process:

### Step 1: Update Document Model via MCP

Use `mcp__reactor-mcp__addActions` with operations such as:

- `SET_OPERATION_SCHEMA` -- Update input/output schemas
- `SET_OPERATION_REDUCER` -- Update reducer code
- `SET_STATE_SCHEMA` -- Update state definitions
- Any other relevant operation from the 37 available

### Step 2: Update Existing Source Files

**Also manually update existing reducer files in the `src/` folder.** These files are NOT auto-generated after initial stub creation. If you only update via MCP but do not update `src/` files, the running code will still have the old logic.

### Why Both Steps Are Required

- **Forgetting Step 1** means future code generations (types, action creators) will not reflect your changes
- **Forgetting Step 2** means the actual running reducer code will not reflect your changes
- **Always do BOTH** to keep the MCP document model definition and the source files in sync

---

## 10. Document Model Creation Workflow

### Phase 1: Planning

**MANDATORY**: Present your proposal to the user and ask for confirmation before implementing ANY document model.

- Describe the proposed document model structure: state schema, operations, modules
- Never proceed with implementation without explicit user approval
- When in doubt, ask for clarification
- Break complex models into logical modules and operations

### Phase 2: Pre-Implementation

**MANDATORY**: Check document model schema before making any MCP tool calls.

1. Use `mcp__reactor-mcp__getDocumentModelSchema` with `type: "powerhouse/document-model"` first
2. Review input schema requirements for operations like `ADD_MODULE`, `ADD_OPERATION`, etc.
3. Ensure all required parameters (like `id` or `scope` fields) are included in action inputs
4. This prevents failed tool calls and reduces iteration

### Phase 3: Implementation

Execute via MCP in this order:

1. Create the document model document using `createDocument` with type `"powerhouse/document-model"`
2. Set header metadata: name, id, extension, description, author
3. Set the state schema using `SET_STATE_SCHEMA` (global and/or local)
4. Set the initial state using `SET_INITIAL_STATE`
5. Add modules using `ADD_MODULE`
6. Add operations to modules using `ADD_OPERATION`
7. Set operation schemas using `SET_OPERATION_SCHEMA`
8. Add operation errors using `ADD_OPERATION_ERROR`
9. Set operation reducers using `SET_OPERATION_REDUCER`
10. Add the document to the vetra drive using `addActions` with `ADD_FILE` action

Batch multiple actions together in a single `addActions` call when possible to minimize API calls.

### Phase 4: Post-Implementation

1. Wait for code generation to complete
2. Open the generated reducer stub files in `document-models/<name>/src/reducers/`
3. Replace all stub implementations with actual reducer logic
4. Ensure error references match the defined error names

### Phase 5: Quality Assurance

Run these commands and fix any issues:

```bash
npm run tsc        # TypeScript type checking
npm run lint:fix   # ESLint checking and auto-fix
```

---

## 11. Specification Driven Design

Powerhouse uses "Specification Driven Design & Development" where schemas serve as machine-readable specifications.

### The Approach

1. **Define data structure** (state schema) in GraphQL
2. **Define operations** (input types) for each state change
3. **Implement reducers** for each operation
4. **System auto-generates**:
   - TypeScript types from GraphQL schemas
   - Action creators for each operation
   - Reducer scaffolding (stubs to be completed)
   - Operation type definitions
   - Document specification files

### Key Concepts

- **Document Model**: The template/definition (schema + operations + reducers)
- **Document**: An instance of a document model containing actual data
- **Action**: A proposed change to a document (JSON object with action name and input). Dispatched using `addActions` tool.
- **Operation**: A completed change containing the action plus metadata (index, timestamp, hash, errors). Actions become operations after dispatch.
- **Drive**: A document of type `powerhouse/document-drive` representing a collection of documents and folders.

### Drive Types

1. **Vetra Drive** (`vetra-{hash}`): Contains source documents (document models and document editors). Used for development.
2. **Preview Drive** (`preview-{hash}`, named "Vetra Preview"): Contains demo and preview documents (document instances). Used for showcasing and testing.
